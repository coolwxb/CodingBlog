
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Promise 学习 - 小小程序猿
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="目前就职于一家北京的创业公司，正在苦逼成长中...">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="小小程序猿" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">小小程序猿</a></h1>
  
    <h2>目前就职于一家北京的创业公司，正在苦逼成长中...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:daycoding.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div>
	<article class="hentry" role="article">
	<header>
			  	<h1 class="entry-title">Promise 学习</h1>
				<p class="meta"><time datetime="2017-03-01T11:33:26+08:00" pubdate data-updated="true">2017/3/1</time></p>
			 </header>
		  	<div class="entry-content">
			  	<p>1.1. 什么是Promise<br/>
Promise是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。<br/>
Promise最初被提出是在 E语言中， 它是基于并列/并行处理设计的一种编程语言。<br/>
另外，如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。</p>

<p>使用了回调函数的异步处理<br/>
·<br/>
getAsync(&quot;fileA.txt&quot;, function(error, result){<br/>
    if(error){// 取得失败时的处理<br/>
        throw error;<br/>
    }<br/>
    // 取得成功时的处理</p>

<h2 id="toc_0">});</h2>

<p><1> 传给回调函数的参数为(error对象， 执行结果)组合<br/>
Node.js等则规定在JavaScript的回调函数的第一个参数为 Error 对象，这也是它的一个惯例。</p>

<p>像上面这样基于回调函数的异步处理如果统一参数使用规则的话，写法也会很明了。 但是，这也仅是编码规约而已，即使采用不同的写法也不会出错。</p>

<p>而Promise则是把类似的异步处理对象和处理规则进行规范化， 并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。</p>

<pre><code>下面是使用了Promise进行异步处理的一个例子
----
var promise = getAsyncPromise(&quot;fileA.txt&quot;); 
promise.then(function(result){
    // 获取文件内容成功时的处理
}).catch(function(error){
    // 获取文件内容失败时的处理
});
----
&lt;1&gt; 返回promise对象
</code></pre>

<p>我们可以向这个预设了抽象化异步处理的promise对象， 注册这个promise对象执行成功时和失败时相应的回调函数。</p>

<p>这和回调函数方式相比有哪些不同之处呢？ 在使用promise进行一步处理的时候，我们必须按照接口规定的方法编写处理代码。</p>

<p>也就是说，除promise对象规定的方法(这里的 then 或 catch)以外的方法都是不可以使用的， 而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。</p>

<p>这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模式。</p>

<p>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化， 这也可以说得上是使用promise的理由之一。</p>

<p>目前大致有下面三种类型。</p>

<p>Constructor</p>

<p>Promise类似于 XMLHttpRequest，从构造函数 Promise 来创建一个新建新promise对象作为接口。</p>

<p>要想创建一个promise对象、可以使用new来调用Promise的构造器来进行实例化。</p>

<p>var promise = new Promise(function(resolve, reject) {<br/>
    // 异步处理<br/>
    // 处理结束后、调用resolve 或 reject<br/>
});<br/>
Instance Method</p>

<p>对通过new生成的promise对象为了设置其值在 resolve(成功) / reject(失败)时调用的回调函数 可以使用promise.then() 实例方法。</p>

<p>promise.then(onFulfilled, onRejected)<br/>
resolve(成功)时<br/>
onFulfilled 会被调用</p>

<p>reject(失败)时<br/>
onRejected 会被调用<br/>
onFulfilled、onRejected 两个都为可选参数。</p>

<p>promise.then 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 promise.then(undefined, onRejected) 这种方式，只指定reject时的回调函数即可。 不过这种情况下 promise.catch(onRejected) 应该是个更好的选择。</p>

<p>promise.catch(onRejected)<br/>
Static Method</p>

<p>像 Promise 这样的全局对象还拥有一些静态方法。</p>

<p>包括 Promise.all() 还有 Promise.resolve() 等在内，主要都是一些对Promise进行操作的辅助方法。</p>

<p>1.2.2. Promise的状态<br/>
我们已经大概了解了Promise的处理流程，接下来让我们来稍微整理一下Promise的状态。</p>

<p>用new Promise 实例化的promise对象有以下三个状态。</p>

<p>&quot;has-resolution&quot; - Fulfilled<br/>
resolve(成功)时。此时会调用 onFulfilled</p>

<p>&quot;has-rejection&quot; - Rejected<br/>
reject(失败)时。此时会调用 onRejected</p>

<p>&quot;unresolved&quot; - Pending<br/>
既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等<br/>
关于上面这三种状态的读法，其中 左侧为在 ES6 Promises 规范中定义的术语， 而右侧则是在 Promises/A+ 中描述状态的术语。</p>

<p>.3.1. 创建promise对象<br/>
创建promise对象的流程如下所示。</p>

<p>new Promise(fn) 返回一个promise对象</p>

<p>在fn 中指定异步等处理</p>

<p>处理结果正常的话，调用resolve(处理结果值)</p>

<p>处理结果错误的话，调用reject(Error对象)</p>

<p>promise对象拥有几个实例方法， 我们使用这些实例方法来为promise对象创建依赖于promise的具体状态、并且只会被执行一次的回调函数。</p>

<p>为promise对象添加处理方法主要有以下两种</p>

<p>promise对象被 resolve 时的处理(onFulfilled)</p>

<p>promise对象被 reject 时的处理(onRejected)</p>

<p>promise-resolve-flow<br/>
Figure 2. promise value flow<br/>
首先，我们来尝试一下为 getURL 通信成功并取到值时添加的处理函数。</p>

<p>此时所谓的 通信成功 ， 指的就是在被resolve后， promise对象变为FulFilled状态 。</p>

<p>被resolve后的处理，可以在.then 方法中传入想要调用的函数。</p>

<p>var URL = &quot;<a href="http://httpbin.org/get">http://httpbin.org/get</a>&quot;;<br/>
getURL(URL).then(function onFulfilled(value){ <br/>
    console.log(value);<br/>
});<br/>
为了方便理解我们把函数命名为 onFulfilled</p>

<p>总结</p>

<p>在本章我们简单介绍了以下内容：</p>

<p>用 new Promise 方法创建promise对象</p>

<p>用.then 或 .catch 添加promise对象的处理函数</p>

<p>2.1. Promise.resolve<br/>
一般情况下我们都会使用 new Promise() 来创建promise对象，但是除此之外我们也可以使用其他方法。</p>

<p>在这里，我们将会学习如何使用 Promise.resolve 和 Promise.reject这两个方法。</p>

<p>2.1.1. new Promise的快捷方式<br/>
静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。</p>

<p>比如 Promise.resolve(42); 可以认为是以下代码的语法糖。</p>

<p>new Promise(function(resolve){<br/>
    resolve(42);<br/>
});<br/>
在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。</p>

<p>方法 Promise.resolve(value); 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。</p>

<p>Promise.resolve(42).then(function(value){<br/>
    console.log(value);<br/>
});<br/>
运行<br/>
Promise.resolve作为 new Promise() 的快捷方式，在进行promise对象的初始化或者编写测试代码的时候都非常方便。</p>

<p>2.1.2. Thenable<br/>
Promise.resolve 方法另一个作用就是将 thenable 对象转换为promise对象。</p>

<p>ES6 Promises里提到了Thenable这个概念，简单来说它就是一个非常类似promise的东西。</p>

<p>就像我们有时称具有 .length 方法的非数组对象为Array like一样，thenable指的是一个具有 .then 方法的对象。</p>

<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的 then 方法应该和Promise所拥有的 then 方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的 then 方法。</p>

<p>到底什么样的对象能算是thenable的呢，最简单的例子就是 jQuery.ajax()，它的返回值就是thenable的。</p>

<p>因为jQuery.ajax() 的返回值是 jqXHR Object 对象，这个对象具有 .then 方法。</p>

<p>$.ajax(&#39;/json/comment.json&#39;);// =&gt; 拥有 <code>.then</code> 方法的对象<br/>
这个thenable的对象可以使用 Promise.resolve 来转换为一个promise对象。</p>

<p>变成了promise对象的话，就能直接使用 then 或者 catch 等这些在 ES6 Promises里定义的方法了。</p>

<p>将thenable对象转换promise对象<br/>
var promise = Promise.resolve($.ajax(&#39;/json/comment.json&#39;));// =&gt; promise对象<br/>
promise.then(function(value){<br/>
   console.log(value);<br/>
});<br/>
jQuery和thenable<br/>
jQuery.ajax()的返回值是一个具有 .then 方法的 jqXHR Object对象，这个对象继承了来自 Deferred Object 的方法和属性。</p>

<p>但是Deferred Object并没有遵循Promises/A+或ES6 Promises标准，所以即使看上去这个对象转换成了一个promise对象，但是会出现缺失部分信息的问题。</p>

<p>这个问题的根源在于jQuery的 Deferred Object 的 then 方法机制与promise不同。</p>

<p>所以我们应该注意，即使一个对象具有 .then 方法，也不一定就能作为ES6 Promises对象使用。</p>

<p>JavaScript Promises: There and back again - HTML5 Rocks</p>

<p>You&#39;re Missing the Point of Promises</p>

<p><a href="https://twitter.com/hirano_y_aa/status/398851806383452160">https://twitter.com/hirano_y_aa/status/398851806383452160</a></p>

<p>Promise.resolve 只使用了共通的方法 then ，提供了在不同的类库之间进行promise对象互相转换的功能。</p>

<p>这种转换为thenable的功能在之前是通过使用 Promise.cast 来完成的，从它的名字我们也不难想象它的功能是什么。</p>

<p>除了在编写使用Promise的类库等软件时需要对Thenable有所了解之外，通常作为end-user使用的时候，我们可能不会用到此功能。</p>

<p>我们会在后面第4章的Promise.resolve和Thenable中进行详细的说明，介绍一下结合使用了Thenable和Promise.resolve的具体例子。<br/>
简单总结一下 Promise.resolve 方法的话，可以认为它的作用就是将传递给它的参数填充（Fulfilled）到promise对象后并返回这个promise对象。</p>

<p>此外，Promise的很多处理内部也是使用了 Promise.resolve 算法将值转换为promise对象后再进行处理的。</p>

<p>2.2. Promise.reject<br/>
Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</p>

<p>比如 Promise.reject(new Error(&quot;出错了&quot;)) 就是下面代码的语法糖形式。</p>

<p>new Promise(function(resolve,reject){<br/>
    reject(new Error(&quot;出错了&quot;));<br/>
});<br/>
这段代码的功能是调用该promise对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。</p>

<p>Promise.reject(new Error(&quot;BOOM!&quot;)).catch(function(error){<br/>
    console.error(error);<br/>
});</p>

<p>它和Promise.resolve(value) 的不同之处在于promise内调用的函数是reject而不是resolve，这在编写测试代码或者进行debug时，说不定会用得上。</p>

<p>Promise只能进行异步操作？<br/>
在使用Promise.resolve(value) 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 .then 里面指定的方法就是同步调用的呢？</p>

<p>实际上， .then 中指定的方法调用是异步进行的。</p>

<p>var promise = new Promise(function (resolve){<br/>
    console.log(&quot;inner promise&quot;); // 1<br/>
    resolve(42);<br/>
});<br/>
promise.then(function(value){<br/>
    console.log(value); // 3<br/>
});<br/>
console.log(&quot;outer promise&quot;); // 2<br/>
运行<br/>
执行上面的代码会输出下面的log，从这些log我们清楚地知道了上面代码的执行顺序。</p>

<p>inner promise // 1<br/>
outer promise // 2<br/>
42            // 3<br/>
由于JavaScript代码会按照文件的从上到下的顺序执行，所以最开始 <1> 会执行，然后是 resolve(42); 被执行。这时候 promise 对象的已经变为确定状态，FulFilled被设置为了 42 。</p>

<p>下面的代码 promise.then 注册了 <3> 这个回调函数，这是本专栏的焦点问题。</p>

<p>由于 promise.then 执行的时候promise对象已经是确定状态，从程序上说对回调函数进行同步调用也是行得通的。</p>

<p>但是即使在调用 promise.then 注册回调函数的时候promise对象已经是确定的状态，Promise也会以异步的方式调用该回调函数，这是在Promise设计上的规定方针。</p>

<p>因此 <2> 会最先被调用，最后才会调用回调函数 <3> 。</p>

<p>为什么要对明明可以以同步方式进行调用的函数，非要使用异步的调用方式呢？</p>

<p>2.3.1. 同步调用和异步调用同时存在导致的混乱<br/>
其实在Promise之外也存在这个问题，这里我们以一般的使用情况来考虑此问题。</p>

<p>这个问题的本质是接收回调函数的函数，会根据具体的执行情况，可以选择是以同步还是异步的方式对回调函数进行调用。</p>

<p>下面我们以 onReady(fn) 为例进行说明，这个函数会接收一个回调函数进行处理。</p>

<p>console.log(&#39;DOM fully loaded and parsed&#39;);<br/>
1<br/>
function onReady(fn) {<br/>
2<br/>
    var readyState = document.readyState;<br/>
3<br/>
    if (readyState === &#39;interactive&#39; || readyState === &#39;complete&#39;) {<br/>
4<br/>
        fn();<br/>
5<br/>
    } else {<br/>
6<br/>
        window.addEventListener(&#39;DOMContentLoaded&#39;, fn);<br/>
7<br/>
    }<br/>
8<br/>
}<br/>
9<br/>
onReady(function () {<br/>
10<br/>
    console.log(&#39;DOM fully loaded and parsed&#39;);<br/>
11<br/>
});<br/>
12<br/>
console.log(&#39;<mark>Starting</mark>&#39;);<br/>
运行  清除log  退出<br/>
DOM fully loaded and parsed<br/>
<mark>Starting</mark><br/>
mixed-onready.js会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。</p>

<p>如果在调用onReady之前DOM已经载入的话<br/>
对回调函数进行同步调用</p>

<p>如果在调用onReady之前DOM还没有载入的话<br/>
通过注册 DOMContentLoaded 事件监听器来对回调函数进行异步调用<br/>
因此，如果这段代码在源文件中出现的位置不同，在控制台上打印的log消息顺序也会不同。</p>

<p>为了解决这个问题，我们可以选择统一使用异步调用的方式。</p>

<p>1<br/>
function onReady(fn) {<br/>
2<br/>
    var readyState = document.readyState;<br/>
3<br/>
    if (readyState === &#39;interactive&#39; || readyState === &#39;complete&#39;) {<br/>
4<br/>
        setTimeout(fn, 0);<br/>
5<br/>
    } else {<br/>
6<br/>
        window.addEventListener(&#39;DOMContentLoaded&#39;, fn);<br/>
7<br/>
    }<br/>
8<br/>
}<br/>
9<br/>
onReady(function () {<br/>
10<br/>
    console.log(&#39;DOM fully loaded and parsed&#39;);<br/>
11<br/>
});<br/>
12<br/>
console.log(&#39;<mark>Starting</mark>&#39;);<br/>
运行  清除log  退出<br/>
<mark>Starting</mark><br/>
DOM fully loaded and parsed<br/>
<mark>Starting</mark><br/>
DOM fully loaded and parsed<br/>
关于这个问题，在 Effective JavaScript 的 第67项 不要对异步回调函数进行同步调用 中也有详细介绍。</p>

<p>绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</p>

<p>如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</p>

<p>对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。</p>

<p>如果想在将来某时刻调用异步回调函数的话，可以使用 setTimeout 等异步API。</p>

<p>Effective JavaScript<br/>
— David Herman<br/>
前面我们看到的 promise.then 也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定 Promise只能使用异步调用方式 。</p>

<p>promise可以写成方法链的形式<br/>
aPromise.then(function taskA(value){<br/>
// task A<br/>
}).then(function taskB(vaue){<br/>
// task B<br/>
}).catch(function onRejected(error){<br/>
    console.log(error);<br/>
});<br/>
如果把在 then 中注册的每个回调函数称为task的话，那么我们就可以通过Promise方法链方式来编写能以taskA → task B 这种流程进行处理的逻辑了。</p>

<p>Promise方法链这种叫法有点长（其实是在日语里有点长，中文还可以 --译者注），因此后面我们会简化为 promise chain 这种叫法。</p>

<p>Promise之所以适合编写异步处理较多的应用，promise chain可以算得上是其中的一个原因吧。</p>

<p>在第一章 promise chain 里我们看到了一个很简单的 then → catch 的例子，如果我们将方法链的长度变得更长的话，那在每个promise对象中注册的onFulfilled和onRejected将会怎样执行呢？</p>

<p>promise chain - 即方法链越短越好。 在这个例子里我们是为了方便说明才选择了较长的方法链。<br/>
我们先来看看下面这样的promise chain。</p>

<p>1<br/>
function taskA() {<br/>
2<br/>
    console.log(&quot;Task A&quot;);<br/>
3<br/>
}<br/>
4<br/>
function taskB() {<br/>
5<br/>
    console.log(&quot;Task B&quot;);<br/>
6<br/>
}<br/>
7<br/>
function onRejected(error) {<br/>
8<br/>
    console.log(&quot;Catch Error: A or B&quot;, error);<br/>
9<br/>
}<br/>
10<br/>
function finalTask() {<br/>
11<br/>
    console.log(&quot;Final Task&quot;);<br/>
12<br/>
}<br/>
13<br/>
​<br/>
14<br/>
var promise = Promise.resolve();<br/>
15<br/>
promise<br/>
16<br/>
    .then(taskA)<br/>
17<br/>
    .then(taskB)<br/>
18<br/>
    .catch(onRejected)<br/>
19<br/>
    .then(finalTask);<br/>
运行  清除log  退出<br/>
Task A<br/>
Task B<br/>
Final Task<br/>
上面代码中的promise chain的执行流程，如果用一张图来描述一下的话，像下面的图那样。</p>

<p>promise-then-catch-flow<br/>
Figure 3. promise-then-catch-flow.js附图<br/>
在 上述代码 中，我们没有为 then 方法指定第二个参数(onRejected)，也可以像下面这样来理解。</p>

<p>then<br/>
注册onFulfilled时的回调函数</p>

<p>catch<br/>
注册onRejected时的回调函数<br/>
再看一下 上面的流程图 的话，我们会发现 Task A 和 Task B 都有指向 onRejected 的线出来。</p>

<p>这些线的意思是在 Task A 或 Task B 的处理中，在下面的情况下就会调用 onRejected 方法。</p>

<p>发生异常的时候</p>

<p>返回了一个Rejected状态的promise对象</p>

<p>在 第一章 中我们已经看到，Promise中的处理习惯上都会采用 try-catch 的风格，当发生异常的时候，会被 catch 捕获并被由在此函数注册的回调函数进行错误处理。</p>

<p>另一种异常处理策略是通过 返回一个Rejected状态的promise对象 来实现的，这种方法不通过使用 throw 就能在promise chain中对 onRejected 进行调用。</p>

<p>关于这种方法由于和本小节关系不大就不在这里详述了，大家可以参考一下第4章 使用reject而不是throw 中的内容。</p>

<p>此外在promise chain中，由于在 onRejected 和 Final Task 后面没有 catch 处理了，因此在这两个Task中如果出现异常的话将不会被捕获，这点需要注意一下。</p>

<p>下面我们再来看一个具体的关于 Task A → onRejected 的例子。</p>

<p>Task A产生异常的例子</p>

<p>Task A 处理中发生异常的话，会按照TaskA → onRejected → FinalTask 这个流程来进行处理。</p>

<p>promise taska rejected flow<br/>
Figure 4. Task A产生异常时的示意图<br/>
将上面流程写成代码的话如下所示。</p>

<p>promise-then-taska-throw.js<br/>
function taskA() {<br/>
    console.log(&quot;Task A&quot;);<br/>
    throw new Error(&quot;throw Error @ Task A&quot;)<br/>
}<br/>
function taskB() {<br/>
    console.log(&quot;Task B&quot;);// 不会被调用<br/>
}<br/>
function onRejected(error) {<br/>
    console.log(error);// =&gt; &quot;throw Error @ Task A&quot;<br/>
}<br/>
function finalTask() {<br/>
    console.log(&quot;Final Task&quot;);<br/>
}</p>

<p>var promise = Promise.resolve();<br/>
promise<br/>
    .then(taskA)<br/>
    .then(taskB)<br/>
    .catch(onRejected)<br/>
    .then(finalTask);<br/>
运行<br/>
执行这段代码我们会发现 Task B 是不会被调用的。</p>

<p>在本例中我们在taskA中使用了 throw 方法故意制造了一个异常。但在实际中想主动进行onRejected调用的时候，应该返回一个Rejected状态的promise对象。关于这种两种方法的异同，请参考 使用reject而不是throw 中的讲解。<br/>
2.4.2. promise chain 中如何传递参数<br/>
前面例子中的Task都是相互独立的，只是被简单调用而已。</p>

<p>这时候如果 Task A 想给 Task B 传递一个参数该怎么办呢？</p>

<p>答案非常简单，那就是在 Task A 中 return 的返回值，会在 Task B 执行时传给它。</p>

<p>我们还是先来看一个具体例子吧。</p>

<p>promise-then-passing-value.js<br/>
function doubleUp(value) {<br/>
    return value * 2;<br/>
}<br/>
function increment(value) {<br/>
    return value + 1;<br/>
}<br/>
function output(value) {<br/>
    console.log(value);// =&gt; (1 + 1) * 2<br/>
}</p>

<p>var promise = Promise.resolve(1);<br/>
promise<br/>
    .then(increment)<br/>
    .then(doubleUp)<br/>
    .then(output)<br/>
    .catch(function(error){<br/>
        // promise chain中出现异常的时候会被调用<br/>
        console.error(error);<br/>
    });<br/>
运行<br/>
这段代码的入口函数是 Promise.resolve(1); ，整体的promise chain执行流程如下所示。</p>

<p>Promise.resolve(1); 传递 1 给 increment 函数</p>

<p>函数 increment 对接收的参数进行 +1 操作并返回（通过return）</p>

<p>这时参数变为2，并再次传给 doubleUp 函数</p>

<p>最后在函数 output 中打印结果</p>

<p>promise-then-passing-value<br/>
Figure 5. promise-then-passing-value.js示意图<br/>
每个方法中 return 的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。</p>

<p>return的值会由 Promise.resolve(return的返回值); 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的promise对象。</p>

<p>关于这部分内容可以参考 专栏: 每次调用then都会返回一个新创建的promise对象 ，那里也对一些常见错误进行了介绍。<br/>
也就是说， Promise#then 不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。</p>

<p>2.5. Promise#catch<br/>
在 前面的Promise#then 的章节里，我们已经简单地使用了 Promise#catch 方法。</p>

<p>这里我们再说一遍，实际上 Promise#catch 只是 promise.then(undefined, onRejected); 方法的一个别名而已。 也就是说，这个方法用来注册当promise对象状态变为Rejected时的回调函数。</p>

<p>关于如何根据场景使用 Promise#then 和 Promise#catch 可以参考  then or catch? 中介绍的内容。<br/>
2.5.1. IE8的问题<br/>
Build Status</p>

<p>上面的这张图，是下面这段代码在使用 polyfill 的情况下在个浏览器上执行的结果。</p>

<p>polyfill是一个支持在不具备某一功能的浏览器上使用该功能的Library。 这里我们使用的例子则来源于 jakearchibald/es6-promise 。<br/>
Promise#catch的运行结果<br/>
var promise = Promise.reject(new Error(&quot;message&quot;));<br/>
promise.catch(function (error) {<br/>
    console.error(error);<br/>
});<br/>
运行<br/>
如果我们在各种浏览器中执行这段代码，那么在IE8及以下版本则会出现 identifier not found 的语法错误。</p>

<p>这是怎么回事呢？ 实际上这和 catch 是ECMAScript的 保留字 (Reserved Word)有关。</p>

<p>在ECMAScript 3中保留字是不能作为对象的属性名使用的。 而IE8及以下版本都是基于ECMAScript 3实现的，因此不能将 catch 作为属性来使用，也就不能编写类似 promise.catch() 的代码，因此就出现了 identifier not found 这种语法错误了。</p>

<p>而现在的浏览器都是基于ECMAScript 5的，而在ECMAScript 5中保留字都属于 IdentifierName ，也可以作为属性名使用了。</p>

<p>在ECMAScript5中保留字也不能作为 Identifier 即变量名或方法名使用。 如果我们定义了一个名为 for 的变量的话，那么就不能和循环语句的 for 区分了。 而作为属性名的话，我们还是很容易区分 object.for 和 for 的，仔细想想我们就应该能接受将保留字作为属性名来使用了。<br/>
当然，我们也可以想办法回避这个ECMAScript 3保留字带来的问题。</p>

<p>点标记法（dot notation） 要求对象的属性必须是有效的标识符（在ECMAScript 3中则不能使用保留字），</p>

<p>但是使用 中括号标记法（bracket notation）的话，则可以将非合法标识符作为对象的属性名使用。</p>

<p>也就是说，上面的代码如果像下面这样重写的话，就能在IE8及以下版本的浏览器中运行了（当然还需要polyfill）。</p>

<p>解决Promise#catch标识符冲突问题<br/>
var promise = Promise.reject(new Error(&quot;message&quot;));<br/>
promise<a href="function%20(error)%20%7B%0A%20%20%20%20console.error(error);%0A%7D">&quot;catch&quot;</a>;<br/>
运行<br/>
或者我们不单纯的使用 catch ，而是使用 then 也是可以避免这个问题的。</p>

<p>使用Promise#then代替Promise#catch<br/>
var promise = Promise.reject(new Error(&quot;message&quot;));<br/>
promise.then(undefined, function (error) {<br/>
    console.error(error);<br/>
});<br/>
运行<br/>
由于 catch 标识符可能会导致问题出现，因此一些类库（Library）也采用了 caught 作为函数名，而函数要完成的工作是一样的。</p>

<p>而且很多压缩工具自带了将 promise.catch 转换为 promise[&quot;catch&quot;] 的功能， 所以可能不经意之间也能帮我们解决这个问题。</p>

<p>如果各位读者需要支持IE8及以下版本的浏览器的话，那么一定要将这个 catch 问题牢记在心中。</p>

<p>2.6. 专栏: 每次调用then都会返回一个新创建的promise对象<br/>
从代码上乍一看， aPromise.then(...).catch(...) 像是针对最初的 aPromise 对象进行了一连串的方法链调用。</p>

<p>然而实际上不管是 then 还是 catch 方法调用，都返回了一个新的promise对象。</p>

<p>下面我们就来看看如何确认这两个方法返回的到底是不是新的promise对象。</p>

<p>var aPromise = new Promise(function (resolve) {<br/>
    resolve(100);<br/>
});<br/>
var thenPromise = aPromise.then(function (value) {<br/>
    console.log(value);<br/>
});<br/>
var catchPromise = thenPromise.catch(function (error) {<br/>
    console.error(error);<br/>
});<br/>
console.log(aPromise !== thenPromise); // =&gt; true<br/>
console.log(thenPromise !== catchPromise);// =&gt; true<br/>
运行<br/>
=== 是严格相等比较运算符，我们可以看出这三个对象都是互不相同的，这也就证明了 then 和 catch 都返回了和调用者不同的promise对象。</p>

<p>Then Catch flow<br/>
我们在对Promise进行扩展的时候需要牢牢记住这一点，否则稍不留神就有可能对错误的promise对象进行了处理。</p>

<p>如果我们知道了 then 方法每次都会创建并返回一个新的promise对象的话，那么我们就应该不难理解下面代码中对 then 的使用方式上的差别了。</p>

<p>// 1: 对同一个promise对象同时调用 <code>then</code> 方法<br/>
var aPromise = new Promise(function (resolve) {<br/>
    resolve(100);<br/>
});<br/>
aPromise.then(function (value) {<br/>
    return value * 2;<br/>
});<br/>
aPromise.then(function (value) {<br/>
    return value * 2;<br/>
});<br/>
aPromise.then(function (value) {<br/>
    console.log(&quot;1: &quot; + value); // =&gt; 100<br/>
})</p>

<p>// vs</p>

<p>// 2: 对 <code>then</code> 进行 promise chain 方式进行调用<br/>
var bPromise = new Promise(function (resolve) {<br/>
    resolve(100);<br/>
});<br/>
bPromise.then(function (value) {<br/>
    return value * 2;<br/>
}).then(function (value) {<br/>
    return value * 2;<br/>
}).then(function (value) {<br/>
    console.log(&quot;2: &quot; + value); // =&gt; 100 * 2 * 2<br/>
});<br/>
运行<br/>
第1种写法中并没有使用promise的方法链方式，这在Promise中是应该极力避免的写法。这种写法中的 then 调用几乎是在同时开始执行的，而且传给每个 then 方法的 value 值都是 100 。</p>

<p>第2中写法则采用了方法链的方式将多个 then 方法调用串连在了一起，各函数也会严格按照 resolve → then → then → then 的顺序执行，并且传给每个 then 方法的 value 的值都是前一个promise对象通过 return 返回的值。</p>

<p>下面是一个由方法1中的 then 用法导致的比较容易出现的很有代表性的反模式的例子。</p>

<p>✘ then 的错误使用方法<br/>
function badAsyncCall() {<br/>
    var promise = Promise.resolve();<br/>
    promise.then(function() {<br/>
        // 任意处理<br/>
        return newVar;<br/>
    });<br/>
    return promise;<br/>
}<br/>
这种写法有很多问题，首先在 promise.then 中产生的异常不会被外部捕获，此外，也不能得到 then 的返回值，即使其有返回值。</p>

<p>由于每次 promise.then 调用都会返回一个新创建的promise对象，因此需要像上述方式2那样，采用promise chain的方式将调用进行链式化，修改后的代码如下所示。</p>

<p>then 返回返回新创建的promise对象<br/>
function anAsyncCall() {<br/>
    var promise = Promise.resolve();<br/>
    return promise.then(function() {<br/>
        // 任意处理<br/>
        return newVar;<br/>
    });<br/>
}<br/>
关于这些反模式，详细内容可以参考 Promise Anti-patterns 。</p>

<p>这种函数的行为贯穿在Promise整体之中， 包括我们后面要进行说明的 Promise.all 和 Promise.race ，他们都会接收一个promise对象为参数，并返回一个和接收参数不同的、新的promise对象。</p>

			</div>

		
	  
		<footer>
		 <p class="meta">

			<strong>Categories:</strong>&nbsp; 
			<span class="categories">
			
			    <a class='category' href='express.html'>express</a>&nbsp;
			 
			</span>
		    </p>
		    <p class="meta">
		      
		 </p>
	    
		<div class="sharing">
		  <!-- 多说评论框 start -->
    <div class="ds-thread" ></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"mweb-zh"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->
          

          

		</div>

	    <p class="meta">
	    
	        <a class="basic-alignment left" href="14892005669552.html" 
	        title="Previous Post: passport">&laquo; passport</a>
	    
	    
	        <a class="basic-alignment right" href="14878507471218.html" 
	        title="Next Post: 拉卡拉项目总结">拉卡拉项目总结 &raquo;</a>
	    
	    </p>
	  </footer>
	</article>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="ios.html"><strong>ios&nbsp;(53)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6.html">基础控件&nbsp;(14)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B1%BB%E5%BA%93.html">第三方类库&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%80%BB%E7%BB%93.html">总结&nbsp;(22)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">基础知识&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Android.html"><strong>Android&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%85%B6%E4%BB%96.html"><strong>其他&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="express.html"><strong>express&nbsp;(12)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="14944963010893.html">webGL浏览器支持</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14944738769390.html">IQKeyboardManager是一个非常方便的库，但是使用的时候有一个坑，一直困扰了我很久。</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14924298431586.html">VSCode 智能感知配置</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14917937079752.html">销售易Pass</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="14914632553537.html">PM2日志分割</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    

<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1a9e7585c72e6c3ff233103ec49aecd2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>
</html>